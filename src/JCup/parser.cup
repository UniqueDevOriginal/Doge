package JCup;
/* ------------------------------Declaração de bibliotecas---------------------------------- */
import java_cup.runtime.*;
import JCup.ParserTokens.*;
import JCup.AuxStruct.AuxArray; 
import java.io.IOException; 
import java.util.ArrayList;

/* Identificar erro no parser, mostra linha e coluna do erro */
parser code {:

    AuxArray aux =  new AuxArray();
    private String type_coming = "";
    private boolean id_need_to_exist = false;
    private String Literal_type = "";
    private ArrayList<String[]> id_info = new ArrayList<>();
    private String[] var_to_assing;

     void create_id_info(String id, String type){
        String[] info = new String[2];
        info[0] = id;
        info[1] = type;
        id_info.add(info);
    }

    void verify_assing(String id) throws IOException{
        int pos = 0;  
        for(int i = 0; i < id_info.size(); i++){
            if (id_info.get(i)[0] == id){
              pos = i;
              break;
            }
        }
        var_to_assing = id_info.get(pos);
        if (!(var_to_assing[1].equals(Literal_type))){
               throw new java.io.IOException("\033[0;31m"+"Trying to assing "+ Literal_type +" to "+ var_to_assing[1]+ "\033[0m"); 
        }
    }

    void wrong_type(String type) throws IOException{
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol)stack.peek();
        if (type.equals("INT")){
            if (type_coming != "INT"){
               throw new java.io.IOException("\033[0;31m"+"Wrong type "+"< "+(s.value)+" >"+" in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m"); 
            }   
        }
        else if (type.equals("CHAR")){
            if (type_coming != "CHAR"){
               throw new java.io.IOException("\033[0;31m"+"Wrong type "+"< "+(s.value)+" >"+" in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m"); 
            }   
        }
        type_coming = "";
    }

    void duplicate_var(String id) throws IOException{
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol)stack.peek();
        for (String newid : aux.nodes_var) {
        if(newid.equals(id)){
            System.out.println();
            throw new java.io.IOException("\033[0;31m"+"Duplicate Var "+"< "+(id)+" >"+" in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m"); 
        }
      }
      aux.nodes_var.add(id);
    }

    void duplicate_function(String id) throws IOException{
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol)stack.peek());
        for (String newid : aux.nodes_function) {
        if(newid.equals(id)){
            System.out.println();
            throw new java.io.IOException("\033[0;31m"+"Duplicate Function "+"< "+(s.value)+" >"+" in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m"); 
        }
      }
      aux.nodes_function.add(id);
    }

    void function_id_exist(String id) throws IOException{
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol)stack.peek());
        boolean exist = false;
        for (String newid : aux.nodes_function) {
        if(newid.equals(id)){
           exist = true;
            }
        }
        if (!exist){
            throw new java.io.IOException("\033[0;31m"+ " Function " + "< " + id + " >" + " isn't declared " + "in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m");
        }
        id_need_to_exist = false;
    }

    void var_id_exist(String id) throws IOException{
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol)stack.peek());
        boolean exist = false;
        for (String newid : aux.nodes_var) {
        if(newid.equals(id)){
           exist = true;
            }
        }
        if (!exist){
            throw new java.io.IOException("\033[0;31m"+ " Variable " + "< " + id + " >" + " isn't declared " + "in line "+(s.left+1)+" on column "+(s.right+1)+" \033[0m");
        }
        id_need_to_exist = false;
    }

    /* Sobrescrever o método report_error para que ele exiba a linha e
        coluna de onde ocorreu o erro na entrada, bem como no
        razão para o erro que é passado para o método no
        String 'mensagem'.  */
    public void report_error(String message, Object info) {

        /* Crie um StringBuilder chamado 'm' com a string 'Erro' nele. */
        System.out.println();
        StringBuilder m = new StringBuilder("\033[0;31m");

        m.append(message);
        /* Verifique se as informações passadas para o método são 
        do tipo java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declara um objeto java_cup.runtime.Symbol 's' com as
                informações  que está sendo convertida. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            /* Verifica se a linha da entrada >= 0 */
            if (s.left >= 0) {
                /* Adiciona msg de erro na linha do erro da entrada. */
                m.append(" in line "+(s.left+1));
                /*  Verifica se a coluna da entrada >= 0 */
                if (s.right >= 0)
                    /* Adiciona msg de erro na coluna do erro da entrada. */
                    m.append(", column "+(s.right+1));
            }
        }
        /* Imprime o conteudo de 'm' que contem a msg de erro, 
        com as informação de linha e coluna e a msg*/
        System.err.println(m+"\033[0m");
    }
    /* Sobrescrever report_fatal_error para exibit linha e coluna do erro 
       alem da mensagem do erro, e termina a execução. */
    public void report_fatal_error(String message, Object info) { 
        report_error(message, info);
        System.exit(1);
    }
:};

/* --------------------------Declaração de terminais e não-terminais------------------------ */
/* ----------Palavras Reservadas----------*/
terminal CHAR;
terminal INT;
terminal TOTHEMOON;
terminal IF;
terminal WHILE;
terminal RETURN;

/* ----------Operadores e pontuação---------*/
terminal String PLUS, MINUS, TIMES, DIVIDE;
terminal COMMA;
terminal LESS, GREATER;
terminal EQUALS, NOTEQUALS;
terminal EQUAL;

/* ----------Delimitadores--------*/
terminal String LEFTPAREN, RIGHTPAREN;
terminal LEFTBRACE, RIGHTBRACE;
terminal SEMI;

/* ----------Tokens Com Valor--------*/
terminal String IDENT;
terminal String CHARACTER;
terminal Integer NUMBER;


/* ---------------------------------Não-terminais------------------------ */

non terminal Program Program;
non terminal Decl    Decl;
non terminal TypeId  TypeId; 
non terminal Id      Id;
non terminal VarDecl VarDecl;
non terminal Var     Var;
non terminal VarList  VarList;
non terminal Argument Argument;
non terminal Block Block; 
non terminal FunctionDecl FunctionDecl;
non terminal Stmt Stmt;
non terminal Expr Expr;
non terminal BlockStmt BlockStmt;
non terminal ReturnValue ReturnValue;
non terminal BinOp BinOp; 
non terminal RelOp RelOp;
non terminal EqOp EqOp;
non terminal AssingOp AssingOp;
non terminal Literal Literal;  
non terminal ArithOp ArithOp; 
non terminal Call ;
non terminal Actuals ;
non terminal ExprComp;

/* ---------------------------------Precedencia dos Terminais-------------------------------- */

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

start with Program;

/* -----------------------------------------Regras de Produção Gramatica Em EBNF--------------------------------------- */

Program     	 ::= Decl:d {: RESULT = new ProgramDecl(d); :};
Decl                ::= VarDecl:vd Decl:d {: RESULT = new DeclVarDecl(vd, d); :}
                        | FunctionDecl:fd Decl:d  {: RESULT = new DeclFunctionDecl(fd, d); :}
                        | /* empty */
                        ;
VarDecl           ::= Var:v SEMI {: RESULT = new VarDeclVar(v); :} 
                        | Var:v AssingOp:ao Literal:lt SEMI {: RESULT = new VarDeclAssingOp(v,ao,lt);:}
                        ;
Var                  ::= TypeId:ti Id:i {: RESULT = new VarTypeId(ti,i); duplicate_var(id_info.get(id_info.size()-1)[0]);:}
                        ;
TypeId             ::= INT:n {: RESULT = new INT(n); type_coming = "INT";:}
                        | CHAR:c {: RESULT = new CHAR(c); type_coming = "CHAR";:}
                        ;
Id                     ::= IDENT:id {:create_id_info(id, type_coming); RESULT = new IDENT(id);:};
FunctionDecl   ::= TypeId:ti IDENT:id {: duplicate_function(id);:} LEFTPAREN Argument:argt RIGHTPAREN Block:bl {: RESULT = new FuncDeclTypeArgBlock(ti,argt, bl);:};
Argument        ::= VarList:vl {: RESULT = new ArgumentVarList(vl);:}
                        | /* empty */
                        ;
VarList            ::= Var:v COMMA VarList:vl {: RESULT = new VarListVarList(v,vl); :}
                        | Var:v {: RESULT = new VarListVar(v); :}
                        ;
Block               ::= LEFTBRACE BlockStmt:blst RIGHTBRACE {: RESULT = new BlockStmtBlock(blst); :};
BlockStmt        ::= VarDecl:vd BlockStmt:blst {: RESULT = new BlockStmtVarDecl(vd, blst); :}
                        | Stmt:st BlockStmt:blst {: RESULT = new BlockStmtStmt(st, blst); :}
                        | /* empty */
                        ;
Stmt                ::=  IF LEFTPAREN ExprComp:ec RIGHTPAREN Block:bl {: RESULT = new StmtIf(ec, bl); :}
                        | WHILE LEFTPAREN ExprComp RIGHTPAREN Block 
                        | Id:i {: var_id_exist(id_info.get(id_info.size()-1)[0]); :} EQUAL Literal:lt SEMI {: verify_assing(id_info.get(id_info.size()-1)[0]); RESULT = new StmtIdEqualLiteralSemi(i, lt);:}
                        | TOTHEMOON LEFTPAREN Id {: /*function_id_exist(temp_id); */:} RIGHTPAREN SEMI
                        | Call
                        | RETURN ReturnValue:rv SEMI {: RESULT = new StmtReturnValue(rv); :}
                        ;
ReturnValue     ::= Expr:ex {: RESULT = new ReturnValueExpr(ex);:} 
                        | Id:i {: RESULT = new ReturnValueId(i); :} 
                        | /* empty */
                        ;
Call                 ::= Id {: function_id_exist(id_info.get(id_info.size()-1)[0]); :}LEFTPAREN Actuals RIGHTPAREN SEMI; 
Actuals            ::= Literal COMMA Actuals 
                        | Literal
                        | /* empty */
                        ;
Expr                ::= NUMBER:lt ArithOp:aro NUMBER:lt2 {: RESULT = new ExprNumberArithOp(lt ,aro,lt2);:}
                        ;
ExprComp      ::= NUMBER BinOp NUMBER {: RESULT = new ExprCompNumBinOpNum(lt, aro, lt2);:}};
Literal             ::= NUMBER:nb {: RESULT = new NUMBER(nb); Literal_type = "INT"; /*wrong_type("INT");*/:}
                        |  CHARACTER:ct  {: RESULT = new CHARACTER(ct); Literal_type = "CHAR"; /*wrong_type("CHAR");*/:}
                        ;
ArithOp           ::= PLUS:plu {: RESULT = new PLUS(plu);:} 
                        | MINUS:min {: RESULT = new MINUS(min);:}
                        | TIMES:tim {: RESULT = new TIMES(tim);:}
                        | DIVIDE:div {: RESULT = new DIVIDE(div);:}
                        ;
AssingOp        ::= EQUAL:eq {: RESULT = new EQUAL(eq); :};
BinOp             ::= RelOp 
                        | EqOp
                        ;    
RelOp               ::= LESS 
                        | GREATER
                        ;
EqOp                ::= EQUALS 
                        | NOTEQUALS
                        ;
