/* ------------------------------Declaração de bibliotecas---------------------------------- */

package JCup;
import java_cup.runtime.*;
import JCup.ParserTokens.*;

/* Identificar erro no parser, mostra linha e coluna do erro */
parser code {:


    /* Sobrescrever o método report_error para que ele exiba a linha e
        coluna de onde ocorreu o erro na entrada, bem como no
        razão para o erro que é passado para o método no
        String 'mensagem'.  */
    public void report_error(String message, Object info) {

        /* Crie um StringBuilder chamado 'm' com a string 'Erro' nele. */
        StringBuilder m = new StringBuilder("Error");

        /* Verifique se as informações passadas para o método são 
        do tipo java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declara um objeto java_cup.runtime.Symbol 's' com as
                informações  que está sendo convertida. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            /* Verifica se a linha da entrada >= 0 */
            if (s.left >= 0) {
                /* Adiciona msg de erro na linha do erro da entrada. */
                m.append(" in line "+(s.left+1));
                /*  Verifica se a coluna da entrada >= 0 */
                if (s.right >= 0)
                    /* Adiciona msg de erro na coluna do erro da entrada. */
                    m.append(", column "+(s.right+1));
            }
        }

        /* Por fim adiciona a mensagem de erro na tela. */
        m.append(" : "+message);

        /* Imprime o conteudo de 'm' que contem a msg de erro, 
        com as informação de linha e coluna e a msg*/
        System.err.println(m);
    }

    /* Sobrescrever report_fatal_error para exibit linha e coluna do erro 
       alem da mensagem do erro, e termina a execução. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};



/* --------------------------Declaração de terminais e não-terminais------------------------ */

terminal SEMI, IDENT, INT, CHAR, MAIN;
terminal LEFTPAREN,  RIGHTPAREN, LEFTBRACE, RIGHTBRACE;
terminal IF, WHILE, PRINT, RETURN;
terminal PLUS, MINUS, TIMES, DIVIDE, EQUAL;
terminal LESS, GREATER, EQUALS, NOTEQUAL;

/* ---------------------------------Não-terminais------------------------ */

non terminal program, decl, var_decl, var, type_id, id;
non terminal argument, block, stmt, location, assing_op, function_decl;
// non terminal program, decl, var_decl, function_decl, var, type_id, arg_list, block, actuals, rel_op, expr, location, literal;
// non terminal call, id, stmt, int_literal, decimal_literal, char_literal, binop, arith_op, eq_op, digit, AssingOp;

/* ---------------------------------Preedencia dos terminais-------------------------------- */

//   precedence left PLUS, MINUS;
//   precedence left TIMES, DIVIDE;
//   start with program;

/* ---------------------------------Declaração da gramatica--------------------------------- */

/* -----------------------------------------Gramatica--------------------------------------- */

program 	    ::= decl;
decl            ::= var_decl | function_decl ;
var_decl        ::= var SEMI;
function_decl   ::= type_id id LEFTPAREN argument RIGHTPAREN block;
var             ::= type_id id;
type_id         ::= INT | CHAR;
id              ::= IDENT;
argument        ::= var ;
block           ::= LEFTBRACE var_decl RIGHTBRACE;


// decl            ::= var_decl | function_decl;
// var_decl        ::= var SEMI;
// function_decl   ::= type_id id LEFTPAREN arg_list RIGHTPAREN block;
// id              ::= var;
// var             ::= type_id;
// arg_list        ::= var;
// type_id         ::= INT | CHAR;
// call            ::= id LEFTPAREN actuals RIGHTPAREN SEMI;
// actuals         ::= expr;
// block           ::= LEFTBRACE var_decl stmt RIGHTBRACE;
// stmt            ::= location AssingOp expr SEMI | call | IF LEFTPAREN expr RIGHTPAREN block| WHILE LEFTPAREN expr RIGHTPAREN block | PRINT LEFTPAREN expr RIGHTPAREN SEMI | RETURN expr SEMI;
// expr            ::= literal | expr binop expr | -expr | LEFTPAREN expr RIGHTPAREN;
// literal         ::= int_literal | char_literal;
// int_literal     ::= decimal_literal;
// decimal_literal ::= digit|digit;
// char_literal    ::= QUOTATION CHAR QUOTATION;
// binop           ::= arith_op | rel_op | eq_op;
// arith_op        ::= PLUS | MINUS | TIMES | DIVIDE;
// rel_op          ::= GREATER | LESS | NOTEQUALS;
// eq_op           ::= EQUALSE | NOTEQUALS;
